<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">

<title>reactStart</title>

<meta name="description" content="reactStart">    


<meta name="apple-mobile-web-app-capable" content="yes" />
<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />

<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

<link rel="stylesheet" href="css/reveal.css">
  <link rel="stylesheet" href="css/theme/moon.css" id="theme">


<!-- For syntax highlighting -->
  <link rel="stylesheet" href="lib/css/zenburn.css">

<style type="text/css">
</style>


<!-- If the query includes 'print-pdf', use the PDF print sheet -->
<script>
  document.write( '<link rel="stylesheet" href="css/print/' +
    ( window.location.search.match( /print-pdf/gi ) ? 'pdf' : 'paper' ) + 
    '.css" type="text/css" media="print">' );
</script>

<!--[if lt IE 9]>
<script src="lib/js/html5shiv.js"></script>
<![endif]-->
</head>

<body>

<div class="reveal">

<!-- Any section element inside of this container is displayed as a slide -->
<div class="slides">

<section>
<h1>reactStart</h1>

<p>
<h4>2016-04-11 17:15:05</h4>
</p>
</section>  


<p>React -start</p>
<section id="react" class="level2">
<h2>React</h2>
<ul>
<li>Facebook</li>
<li>MVC中的V：M -&gt; V</li>
<li>和Flux搭配，可以做到MVVM</li>
<li>默认转义所有字符串，防止XSS攻击</li>
<li>React认为HTML标签及生成这些标签的代码间存在着内在联系，React设计允许你在构建标签结构时充分利用JS的强大能力，而不必在笨拙的模板语言上浪费时间</li>
</ul>
</section>
<section id="why-react" class="level2">
<h2>Why React?</h2>
<ul>
<li>简单:<br />
model改变后，react自动处理用户界面的更新；</li>
<li>声明式:<br />
更新界面时，react仅仅会更新变化的部分；</li>
<li>虚拟Dom:<br />
React在内存中维护一个快速响应的DOM描述，并利用他来快速地计算出差异，然后更新浏览器中的DOM;</li>
</ul>
</section>
<section id="react-最需要走心的工作" class="level2">
<h2>React 最需要走心的工作</h2>
<ul>
<li>构建可组合的、可复用的组件;</li>
<li>组件的好处：代码复用、测试简单;</li>
</ul>
</section>
<section id="react---hello-world" class="level2">
<h2>React - hello world</h2>
<pre><code>&lt;!DOCTYPE html&gt;
&lt;html&gt;
    &lt;head&gt;
        &lt;title&gt;React Hello World&lt;/title&gt;
        &lt;script type=&quot;text/javascript&quot; src=&quot;./react.js&quot;&gt;&lt;/script&gt;
    &lt;/head&gt;
    &lt;body&gt;
        &lt;div id=&quot;app&quot;&gt;&lt;/div&gt;

        &lt;script type=&quot;text/javascript&quot;&gt;
            function h1 (text, style) {
                return &#39;&lt;h1&gt;&#39;&#39; + text + &#39;&lt;/h1&gt;&#39;;
            }
            var el = React.createElement(&#39;h1&#39;, {style: {color: &#39;#00f&#39;}}, &#39;Hello World!&#39;);
            React.render(el, document.getElementById(&#39;app&#39;));
        &lt;/script&gt;
    &lt;/body&gt;
&lt;/html&gt;</code></pre>
</section>
<section id="react---类似的工作" class="level2">
<h2>React - 类似的工作</h2>
<pre><code>&lt;!DOCTYPE html&gt;
&lt;html&gt;
    &lt;head&gt;
        &lt;title&gt;React Hello World&lt;/title&gt;
    &lt;/head&gt;
    &lt;body&gt;
        &lt;div id=&quot;app&quot;&gt;&lt;/div&gt;

        &lt;script type=&quot;text/javascript&quot;&gt;
              function h1 (text, style) {
                var result;
                var styleStr;

                if (style) {
                    styleStr = &#39;style=&quot;&#39;;
                    for (var name in style) {
                        styleStr += name + &#39;:&#39; + style[name] + &#39;;&#39;; 
                    }
                    styleStr += &#39;&quot;&#39;;
                }

                if (styleStr) {
                    result = &#39;&lt;h1 &#39; + styleStr + &#39;&gt;&#39; + text + &#39;&lt;/h1&gt;&#39;;
                } else {
                    result = &#39;&lt;h1&gt;&#39; + text + &#39;&lt;/h1&gt;&#39;;
                }

                  return result;
              }

              function render(target, container) {
                container.innerHTML = target;
              }

              render(h1(&#39;Hello World!&#39;, {color: &#39;#00f&#39;}), document.getElementById(&#39;app&#39;));
        &lt;/script&gt;
    &lt;/body&gt;
&lt;/html&gt;</code></pre>
</section>
<section id="jsx---javascript-xml" class="level2">
<h2>JSX - Javascript XML</h2>
<ul>
<li>优势：
<ul>
<li>类HTML标记语言，都是熟悉的语法</li>
<li>抽象了React Element的创建过程</li>
<li>简单直观，可以提升效率且成本很低</li>
</ul></li>
<li>劣势：
<ul>
<li>在浏览器运行会很慢，项目中需要预处理</li>
</ul></li>
</ul>
</section>
<section id="jsx---hello-world" class="level2">
<h2>JSX - hello world</h2>
<pre><code>&lt;!DOCTYPE html&gt;
&lt;html&gt;
    &lt;head&gt;
        &lt;title&gt;React Hello World&lt;/title&gt;
        &lt;script type=&quot;text/javascript&quot; src=&quot;./react.js&quot;&gt;&lt;/script&gt;
        &lt;script type=&quot;text/javascript&quot; src=&quot;./JSXTransformer.js&quot;&gt;&lt;/script&gt;
    &lt;/head&gt;
    &lt;body&gt;
        &lt;div id=&quot;app&quot;&gt;&lt;/div&gt;

        &lt;script type=&quot;text/jsx&quot;&gt;
            React.render(&lt;h1&gt;Hello World, JSX!&lt;/h1&gt;, document.getElementById(&#39;app&#39;));
        &lt;/script&gt;
    &lt;/body&gt;
&lt;/html&gt;</code></pre>
</section>
<section id="jsx---工作原理" class="level2">
<h2>JSX - 工作原理</h2>
<ol type="1">
<li>使用JSXTransformer通过监听windows的onload/DOMContentLoaded，来遍历所有&quot;text/jsx&quot;脚本标签</li>
<li>获取每个标签的source code并把JSX代码转为react的虚拟dom代码</li>
<li>最后把react代码添加到新建的script标签中</li>
<li>预编译的插件是同理，只不过发生在编译阶段</li>
</ol>
</section>
<section id="jsx-tips" class="level2">
<h2>JSX Tips</h2>
<ul>
<li>JSX设置动态属性时，用花括号包裹Javascript变量</li>
<li>也可以把属性设置为一个函数的调用返回结果</li>
<li>条件判断支持：三元运输符、&amp;&amp;、||</li>
<li>key: 列表时会建议使用，重用组件提升渲染性能</li>
<li>refs：获取创建dom的描述对象 or 获取创建dom的对象, this.refs.usernameInput.getDOMNode() x</li>
<li>HTML关键词：for &gt; htmlFor, class &gt; className, style: {}</li>
<li>事件统一使用驼峰式</li>
</ul>
</section>
<section id="react-tips" class="level2">
<h2>React Tips</h2>
<ul>
<li>React创建的class名称首字母必须大写，不然找不到</li>
<li>JSX可以不换行，换行时必须使用（）包装，不然会报非法组件错误；</li>
<li>只能有根一个节点，多个节点会抛错</li>
<li>内联样式支持对象，名称使用驼峰式，否则不起作用，fontSize</li>
<li>返回：null、false、React组件</li>
</ul>
</section>
<section id="组件的复合" class="level2">
<h2>组件的复合</h2>
<ul>
<li>复用那些接口定义良好的组件来开发新的模块化组件</li>
<li>官网提供的获取子组件的方法：this.props.children X</li>
<li>组件支持 ref=&quot;refId&quot;，访问元素：this.refs.refId</li>
</ul>
</section>
<section id="react---组件数据流" class="level2">
<h2>React - 组件数据流</h2>
<ul>
<li>props</li>
<li>state</li>
</ul>
</section>
<section id="react---dom对象" class="level2">
<h2>React - dom对象</h2>
<ul>
<li>refs</li>
</ul>
</section>
<section id="react---组件生命周期" class="level2">
<h2>React - 组件生命周期</h2>
<section id="组件类创建时" class="level3">
<h3>组件类创建时</h3>
<ul>
<li>getDefaultProps</li>
</ul>
</section>
<section id="初始化" class="level3">
<h3>初始化</h3>
<ul>
<li>getinitialState</li>
</ul>
</section>
<section id="挂载" class="level3">
<h3>挂载</h3>
<ul>
<li>componentWillMount</li>
<li>render</li>
<li>componentDidMount</li>
</ul>
</section>
<section id="更新" class="level3">
<h3>更新</h3>
<ul>
<li>componentWillReceiveProps</li>
<li>shouldComponentUpdate</li>
<li>componentWillUpdate</li>
<li>render</li>
<li>componentDidUpdate</li>
</ul>
</section>
<section id="卸载" class="level3">
<h3>卸载</h3>
<ul>
<li>componentWillUnmount</li>
</ul>
</section>
<section id="class-create-pahses" class="level3">
<h3>Class Create Pahses:</h3>
<pre><code>+ getDefaultProps: invoke while class created and be shared between instances.</code></pre>
</section>
<section id="initialization-pahses" class="level3">
<h3>Initialization Pahses:</h3>
<pre><code>+ constructor: Initialization of state. The instance is now retained.
+ componentWillMount
+ render
+ [children&#39;s constructors]
    - [children&#39;s componentWillMount and render]
    - [children&#39;s componentDidMount]
+ componentDidMount</code></pre>
</section>
<section id="update-phases" class="level3">
<h3>Update Phases:</h3>
<pre><code>+ componentWillReceiveProps (only called if parent updated)
+ shouldComponentUpdate (default: always returns true to prevent subtle bugs)
    - componentWillUpdate
    - render
        + [children&#39;s constructors or receive props phases]
    - componentDidUpdate</code></pre>
</section>
<section id="unmount-phases" class="level3">
<h3>Unmount Phases:</h3>
<pre><code>+ componentWillUnmount
    - [children&#39;s componentWillUnmount]
    - [children destroyed]
+ (destroyed): The instance is now blank, released by React and ready for GC</code></pre>
</section>
</section>
<section id="mixin" class="level2">
<h2>Mixin</h2>
<ul>
<li>独立于组件的</li>
<li>多个组件可共享的</li>
<li>对象类型的配置</li>
</ul>
</section>
<section id="mixin---demo" class="level2">
<h2>Mixin - DEMO</h2>
<pre><code>var userMixin = {
    getDefaultProps: function () {
        return {
            username: &#39;小红&#39;
        };
    },
    renderUser: function (welcomeMsg) {
        return (
                &lt;div className=&quot;user-wrap&quot;&gt;
                    &lt;span ref=&quot;welcomeDesc&quot; className=&quot;welcome-user&quot;&gt;{welcomeMsg}&lt;/span&gt;
                &lt;/div&gt;
            );
    },
    componentDidMount: function () {
        console.log(&#39;mount&#39;);
    }
}


var Header = React.createClass({
    mixins: [userMixin],
    getInitialState: function () {
        return {
            systemName: &#39;React平台Header&#39;
        };
    },
    render: function () {
        var welcomeMsg;
        if (this.props.username) {
            welcomeMsg = &#39;欢迎，&#39; + this.props.username + &#39;！&#39;
        };
        return (
                &lt;div className=&quot;header-content&quot;&gt;
                    &lt;h1&gt;{this.state.systemName}&lt;/h1&gt;
                    {
                        welcomeMsg ? this.renderUser(welcomeMsg) : null
                    }
                &lt;/div&gt;
            );
    }
});</code></pre>
</section>
<section id="react---mixin原理" class="level2">
<h2>React - Mixin原理</h2>
<ul>
<li>Mixin必须是一个对象</li>
<li>在React.createClass（源码：ReactClass &gt; createClass: function (spec) {...}会把Mixin对象融入react对象</li>
<li>融入过程是通过遍历Mixin的属性（for..in）逐个添加到react对象得prototype上（mixSpecIntoComponent）</li>
<li>添加之前需要判断是否已经有了相同属性，且此属性是否支持覆盖、是否支持多个、是否需要合并</li>
<li>添加的方式是：覆盖（override）、合并、多个函数链</li>
</ul>
</section>
<section id="react---mixin融合方式的标准" class="level2">
<h2>React - Mixin融合方式的标准</h2>
<ul>
<li>一些基础的属性是不允许覆盖的，比如：setProps、replaceProps、replaceState、isMounted</li>
<li>渲染的属性是不允许定义多次的，比如：render、shouldComponentUpdate</li>
<li>需要合并的是那些有返回值的，比如：getDefaultProps、getInitialState</li>
<li>其他的都支持多个函数链的形式（先执行已有的，在执行Mixin的），比如：willMount、didMount、willUpdate、didUpdate等等</li>
</ul>
</section>
<section id="react---purerendermixin" class="level2">
<h2>React - PureRenderMixin</h2>
<ul>
<li>React组件的渲染函数是“纯粹的” - 同样的props和state，渲染出同样的效果</li>
<li>可以提升性能 - 在shouldComponentUpdate里检查props、state是否会发生变化</li>
<li>shouldComponentUpdate的判断结果会影响整个组件子树</li>
<li>据说props、state比较是浅比较，不适合(特别)复杂的数据结构</li>
</ul>
</section>
<section id="purerendermixin---shouldcomponentupdate-shallow-check" class="level2">
<h2>PureRenderMixin - shouldComponentUpdate: shallow check</h2>
<pre><code>/**
 - Performs equality by iterating through keys on an object and returning false
 - when any key has values which are not strictly equal between the arguments.
 - Returns true when the values of all keys are strictly equal.
 */
function shallowEqual(objA, objB) {
  if (objA === objB) {
    return true;
  }

  if (typeof objA !== &#39;object&#39; || objA === null || typeof objB !== &#39;object&#39; || objB === null) {
    return false;
  }

  var keysA = Object.keys(objA);
  var keysB = Object.keys(objB);

  if (keysA.length !== keysB.length) {
    return false;
  }

  // Test for A&#39;s keys different from B.
  var bHasOwnProperty = hasOwnProperty.bind(objB);
  for (var i = 0; i &lt; keysA.length; i++) {
    if (!bHasOwnProperty(keysA[i]) || objA[keysA[i]] !== objB[keysA[i]]) {
      return false;
    }
  }

  return true;
}</code></pre>
</section>
<section id="react---表单组件" class="level2">
<h2>React - 表单组件</h2>
<section id="受用户交互影响的属性" class="level3">
<h3>受用户交互影响的属性</h3>
<ul>
<li>value，用于 input、textarea 组件</li>
<li>checked，用于类型为 checkbox 或者 radio 的 input 组件</li>
<li>selected，用于 option 组件</li>
</ul>
</section>
<section id="onchange-回调函数来监听组件变化" class="level3">
<h3>onChange 回调函数来监听组件变化</h3>
<ul>
<li>input 或 textarea 的 value 发生变化时。</li>
<li>input 的 checked 状态改变时。</li>
<li>option 的 selected 状态改变时。</li>
</ul>
</section>
<section id="controlled-components---受限组件" class="level3">
<h3>Controlled Components - 受限组件</h3>
<ul>
<li>设置了 value 的 input 是一个受限组件</li>
</ul>
</section>
<section id="受限组件---demo" class="level3">
<h3>受限组件 - DEMO</h3>
<pre><code>var App = React.createClass({
    getInitialState: function () {
        return {
            phone: &#39;15821466666&#39;
        };
    },
    render: function () {
        return (
                &lt;div&gt;
                    &lt;label htmlFor=&quot;phone&quot;&gt;手机号：&lt;/label&gt;
                    &lt;input type=&#39;text&#39; id=&quot;phone&quot; value={this.state.phone} onChange={this.phoneChangeHlr} /&gt;
                &lt;/div&gt;
            );
    },
    phoneChangeHlr: function (event) {
        this.setState({phone: event.target.value});
    }
});

ReactDOM.render(&lt;App /&gt;, document.getElementById(&#39;app&#39;));</code></pre>
</section>
</section>
<section id="react---add-ons" class="level2">
<h2>React - add-ons</h2>
<ul>
<li>TransitionGroup和CSSTransitionGroup</li>
<li>LinkedStateMixin - 用于简化用户表单输入数据和组件 state 之间的双向数据绑定</li>
<li>classSet，用于更加干净简洁地操作 DOM 中的 class 字符串</li>
<li>cloneWithProps，用于实现 React 组件浅复制，同时改变它们的 props</li>
<li>update，一个辅助方法，使得在 JavaScript 中处理不可变数据更加容易</li>
<li>PureRenderMixin，在某些场景下的性能检测器</li>
</ul>
</section>
<section id="linkedstatemixin---demo" class="level2">
<h2>LinkedStateMixin - DEMO</h2>
<pre><code>var LinkedStateMixin = React.addons.LinkedStateMixin;
var App = React.createClass({
    mixins: [LinkedStateMixin],
    getInitialState: function () {
        return {
            phone: &#39;15821466666&#39;
        };
    },
    render: function () {
        return (
                &lt;div&gt;
                    &lt;label htmlFor=&quot;phone&quot;&gt;手机号：&lt;/label&gt;
                    &lt;input type=&#39;text&#39; id=&quot;phone&quot; valueLink={this.linkState(&#39;phone&#39;)}  /&gt;
                &lt;/div&gt;
            );
    }
});

ReactDOM.render(&lt;App /&gt;, document.getElementById(&#39;app&#39;));</code></pre>
</section>
<section id="开发工具webpack" class="level2">
<h2>开发工具webpack</h2>
<section id="webpack-react-install" class="level3">
<h3>webpack + react install</h3>
<ul>
<li>npm init</li>
<li>npm install --save react react</li>
<li>npm install --save-dev webpack webpack-dev-server</li>
<li>npm install --save-dev jsx-loader css-loader file-loader style-loader url-loader</li>
</ul>
</section>
<section id="configuring-webpack" class="level3">
<h3>Configuring webpack</h3>
<pre><code>var webpack = require(&#39;webpack&#39;);

module.exports = {
    // 它定义了打包的入口文件，数组中的文件会按顺序进行，并且它会自行解决依赖问题。
    entry: {
        main: &#39;./pages/main.js&#39;,
    },
    // 它定义了输出文件的的位置，包括路径，文件名，还可能有运行时的访问路径
    output: {
        path: __dirname + &#39;/build&#39;,
        publicPath: &#39;/build/&#39;,
        filename: &#39;[name].js&#39;
    },
    // Webpack 是使用类似 Browserify 的方式在本地按目录对依赖进行查找。
    // resolve属性中的extensions数组中用于配置程序可以自行补全哪些后缀。
    // 比如 Hello.jsx 这样的文件就可以直接用 require(./Hello) 引用。
    resolve: {
        extensions: [&#39;&#39;, &#39;.js&#39;, &#39;.jsx&#39;]
    },
    // webpack将所有的资源都看做是模块，而模块就需要加载器
    module: {
        loaders: [
            // loaders 指定 jsx-loader 编译后缀名为 .jsx 的文件，
            // 建议给含有 JSX 的文件添加 .jsx 后缀，
            // 当然你也可以直接使用 .js 后缀， 相应的 test 配置正则要修改匹配就是。
            { test: /\.js?$/, exclude: /node_modules/, loader: &#39;jsx?harmony&#39; }, 
            { test: /\.(css)/, loader: &#39;style-loader!css-loader&#39; },
            // inline base64 URLs for &lt;=8k images, direct URLs for the rest
            {test: /\.(png|jpg)$/, loader: &#39;url-loader?limit=8192&#39; } 
            // loaders: [&#39;react-hot&#39;, &#39;jsx?harmony&#39;]
            // loaders后面如果跟的不是数组，则会报错：LoadersList.js:81 r.forEach(function(r) 
        ]
    },
    // 我们可以在plugin参数中配置我们需要用到的各种各样的插件。
    plugins: [
        new webpack.NoErrorsPlugin(),
    ]
}</code></pre>
</section>
<section id="webpack-命令" class="level3">
<h3>Webpack 命令</h3>
<p>启动webpack命令 - webpack -d 提供SourceMaps，方便调试 - webpack -w 提供watch方法，实时进行打包更新 - webpack --colors 输出结果带彩色，比如：会用红色显示耗时较长的步骤 - webpack --progress 输出的接口带进度 - webpack --profile 输出性能数据，可以看到每一步的耗时 - webpack -p 对打包后的文件进行压缩 - webpack --config <filename> 支持指定实用的配置文件，处理release和debug不同的情况</p>
</section>
<section id="配置scripts" class="level3">
<h3>配置scripts</h3>
<pre><code>&quot;scripts&quot;: {
    &quot;locDev&quot;: &quot;webpack -d -w --progress --colors&quot;,
    &quot;serDev&quot;: &quot;webpack-dev-server --progress --colors --port 8082&quot;
}</code></pre>
</section>
<section id="运行" class="level3">
<h3>运行</h3>
<ul>
<li>npm run locDev</li>
<li>npm run serDev</li>
</ul>
</section>
<section id="react---热插拔" class="level3">
<h3>React - 热插拔</h3>
<ul>
<li>npm install --save-dev react-hot-loader</li>
<li>webpack.config.js: entry 使用数组，并添加 'webpack/hot/only-dev-server'</li>
<li>webpack.config.js: loaders: ['react-hot', 'jsx?harmony']</li>
<li>入口文件添加 module.hot.accept()</li>
<li>启动：webpack-dev-server -d --port 8082 --hot --progress --colors</li>
</ul>
</section>
<section id="react---热拔插多个入口" class="level3">
<h3>React - 热拔插多个入口</h3>
<ul>
<li>webpack.config.js: entry: entry: { main: ['./pages/main/index.js', 'webpack/hot/only-dev-server'], help: ['./pages/help/index.js', 'webpack/hot/only-dev-server'] }</li>
</ul>
</section>
</section>
<section id="react---render时机" class="level2">
<h2>React - render时机</h2>
<section id="批量更新---事件回调函数" class="level3">
<h3>批量更新 - 事件回调函数</h3>
<ul>
<li>事件处理函数中的多次setState/replaceState会被标记为一次批量更新</li>
<li>事件处理函数本身在React事件机制中是作为一个回调函数被调用，在函数执行完成后才会触发render</li>
</ul>
</section>
<section id="实时更新---其他" class="level3">
<h3>实时更新 - 其他</h3>
<ul>
<li>调用setState/replaceState后直接触发render，比如setInterval</li>
</ul>
</section>
<section id="render流程" class="level3">
<h3>render流程</h3>
<ul>
<li>setState/replaceState 修改状态后</li>
<li>组件添加等待更新的状态列表，并把新的状态压入列表（ReactUpdateQueue.js: enqueueSetState()）</li>
<li>标记组件为需要重新渲染的组件（dirty components list）ReactUpdates：enqueueUpdate()</li>
<li>runBatchedUpdates来处理dirty components（调用对应的render）</li>
</ul>
</section>
</section>
<section id="react---react事件系统" class="level2">
<h2>React - React事件系统</h2>
<ol type="1">
<li>React初始化时会把事件监听 ReactEventListener 注入到 ReactBrowserEventEmitter</li>
<li>ReactBrowserEventEmitter 是浏览器事件的顶级委托，ReactEventListener 为用户绑定事件的DOM绑定自己的处理函数，并在处理函数中调用用户的事件处理函数，然后理render相关逻辑；</li>
<li>React 事件系统：
<ul>
<li>浏览器事件的顶级委托（top-level delegation）用来 trap (捕获？) 大多数原生浏览器事件，可以注入事件处理器；</li>
<li>主线程唯一的工作是注入的 ReactEventListener（是为可插拔事件源准备的事件监听器）；</li>
<li>转发这些被 trap 原生浏览器事件至 EventPluginHub， EventPluginHub 在提取任何组合事件时会调用对应插件（比如 SimpleEventPlugin ）并返回需要处理的事件列表；</li>
<li>事件插件包括：ResponderEventPlugin、SimpleEventPlugin、TapEventPlugin、EnterLeaveEventPlugin、ChangeEventPlugin、SelectEventPlugin、BeforeInputEventPlugin</li>
<li>EventPluginHub 同时会维护Dom、事件名称和事件处理器的Mapping；</li>
<li>ReactEventListener 监听 EventPluginHub 的事件，并处理事件派发及事件响应</li>
<li>ReactEventListener 的事件响应函数会处理用户的事件处理函数</li>
</ul></li>
<li>React组件及组件树的渲染都是在ReactMount里面执行</li>
<li>mount组件时，初始化组件并注册事件监听（mountComponent）</li>
<li>事件响应由ReactEventListener的dispatchEvent触发，通过EventPluginHub找到事件处理相关</li>
<li>我们的事件函数作为回调处理</li>
</ol>
</section>
</div>

<script src="lib/js/head.min.js"></script>
<script src="js/reveal.js"></script>

<script>
  // Full list of configuration options available here:
  // https://github.com/hakimel/reveal.js#configuration
  Reveal.initialize({
    controls: true,
    progress: true,
    history: true,
    center: false,
    // Enable the slide overview mode
    overview: true,

  // available themes are in /css/theme
      theme: Reveal.getQueryHash().theme || 'moon', 
  
  // default/cube/page/concave/zoom/linear/fade/none
      transition: Reveal.getQueryHash().transition || 'zoom',
  
  // Optional libraries used to extend on reveal.js
  dependencies: [
    { src: 'lib/js/classList.js', condition: function() { return !document.body.classList; } },
    { src: 'plugin/markdown/showdown.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
    { src: 'plugin/markdown/markdown.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
    { src: 'plugin/highlight/highlight.js', async: true, callback: function() { hljs.initHighlightingOnLoad(); } },
    { src: 'plugin/zoom-js/zoom.js', async: true, condition: function() { return !!document.body.classList; } },
    { src: 'plugin/notes/notes.js', async: true, condition: function() { return !!document.body.classList; } }
    // { src: 'plugin/remotes/remotes.js', async: true, condition: function() { return !!document.body.classList; } }
  ]
  });

</script>

</body>
</html>